7장의 생각할 거리
저자가 지적한대로 모듈 하나가 하나의 일만 하는 것으로 생각했었다
하지만 이 것은 함수는 하나의 일을 처리해야 한다는 저자의 설명이 덧붙음으로서 나의 오해를 깨달을 수 있었다

좋은 모듈은 응집성이 좋아야 한다고 들었던 부분이 책에도 그대로 나온다
또한 응집성이 약한 경우 많은 사람이 다른 목적으로 같은 소스코드를 수정하는 실제로 개발할 때 자주 접하는 문제가 이와 관련있음을 깨달았다

단일 책임 원칙은 캡슐화와 연관된 것일까?

8장의 생각할 거리
개방 폐쇄의 원칙은 어쩌면 가장 중요한 원칙이 아닐까
또한 그만큼 지키기 어렵다는 뜻이 되지 않을까 싶다
그렇다면 확장과 변경의 차이는 무엇일까?
둘 다 바뀌는 것은 같은데 어떤 차이로 확장은 허용되고 변경은 막아야 하는 것일까?
변경으로 인한 오류의 파생효과 때문일까?

컴포넌트의 관계가 일방적인 의존성 역전 원칙을 다시금 새겨본다...
개방 폐쇄 원칙이 소프트웨어를 배우는 가장 근본 원인과 맞닿아 있는 것일까?

9장의 생각할 거리
리스코프 치환 원리를 서로 다른 객체가 서로 의존성이 없고 이를 바꿀 수 있다는 것으로 이해했다
그렇다면 같은 인터페이스를 상속받아 다른 오브젝트에서 인터페이스를 호출하는 것과 같은 것일까?
저자의 설명에서도 이 원칙은 상속을 지원하는 형태로 설명하는 것을 보아 다형성과 연관되는 것 같다

11장의 생각할 거리
객체지향의 힘으로 지정한 이 원리는 매우 중요한 것 같다
저자가 꼽은 주요한 기능으로 추정된다

13장의 생각할 거리
재사용/릴리스 등가원칙은 매우 중요하지만 권장 사항정도로 되어 사람들이 쉽게 놓칠만한 것이라고 생각하는 것 같다

공통 폐쇄 원칙의 폐쇄는 전에 나왔던 캡슐화와 연결되는 것인가??

즉 응집도를 높이는 단계에서도 재사용/릴리스 등가원칙, 공통폐쇄원칙, 공통 재사용성의 원칙에서 적절한 선택이 꼭 필요한 것이다
선택들 중 우리의 소프트웨어에 가장 적합한 것은 매번 달라질 수도 있다는 것이다

14장 생각할 거리
의존성 비순환 원칙은 다이아몬드 상속 혹은 순환 상속같은 형태가 일어나선 안 된다는 것과 같은 맥락의 이야기인가?

아무런 클래스 없이 컴포넌트 의존성을 설계하려하면 반드시 실패할 것이라고 저자는 진단한다
이 역시 나의 예상과 달랐다 철저하게 설계하고 그를 토대로 만들어야 하는 것이 아닌가?
