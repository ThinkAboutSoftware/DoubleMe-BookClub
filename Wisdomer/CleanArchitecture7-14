줄거리 요약
SOLID 원칙
변경이 쉬움, 이해가 쉬움, 컴포넌트의 기반

7장 단일 책임 원칙
SRP single responsibility principle

모듈은 하나의 액터에 대해서만 책임지는 것
응집성이 높아야 함
데이터와 메서드를 분리하기
여러 클래스로 분할되어 추적이 어려운 경우 파사드 패턴을 적용
단일 책임 원칙은 클래스와 메서드의 원칙이나 상위로 올라가면 공통 폐쇄의 원칙이 됨

8장 개방 폐쇄 원칙
Open closed principle

객체는 확장에는 열리고 변경에 닫혀있어야 한다

소프트웨어를 배우는 주요 이유
예시를 들 때 책임을 나누고 그 처리과정을 클래스로 나누고 클래스 묶음을 컴포넌트로 나누었다
아키텍트에서 기능을 나누기 > 컴포넌트의 계층구조로 나누기 > 조직화를 하며 보호의 계층 수준을 나누기
인터페이스는 추이종속성을 막는 중요한 기능을 담당
확장은 쉽고 변경에서 시스템을 보호하는 것

9장 리스코프 치환 원리
Liscov Substitution Principle

하나의 객체를 다른 객체로 치환했을 때 그를 활용한 객체의 행동이 변화가 없으면 치환된 객체는 치환한 객체의 하위객체가 된다
상속을 지원하는 형태

10장 인터페이스 분리 원칙
Interface Seperation Principle

동적 언어의 경우는 소스코드 의존성이 없다고하니 언어, 프레임워크의 문제라고 진단한다

11장 의존성 역전 원칙
Dependency Inversion Principle

유연성이 극대화된 코드는 모든 의존성이 추상적인 것에 의존하는 것

모든 의존성을 피하는 것이 아니라 변동성이 큰 구체적인 모듈 의존성을 줄이는 것
추상적인 인터페이스에 의존하기
추상팩토리 기법
의존성 역전원리 : 제어 흐름이 의존성과 역전되는 현상

12장 컴포넌트

시스템의 가장 작은 배포단위

자바의 jar,루비의 gem, 닷넷의 dll
동적으로 재배치가 가능한 링크와 로더의 기능이 컴퓨터 연산이 빨라지면서 
링크와 로드 시간이 줄고 이는 컴포넌트 플러그인 아키텍쳐가 탄생함
동적 링크 파일이 컴포넌트

13장 컴포넌트 응집도

재사용/릴리스 등가원칙
공통 폐쇄 원칙
공통 재사용 원칙

재사용/릴리스 등가원칙

재사용 단위=릴리스 단위
컴포넌트는 같은 버전으로 모든 기능이 묶여 배포되어야 함
즉 하나로 묶인 클래스, 모듈은 반드시 함께 릴리스 되어야 한다
dll등의 버전이 내부 클래스가 바뀔 때 같이 묶여서 바뀐 내용을 지원해야 하는 것과 같은 원칙 같다

공통 폐쇄 원칙
같은 이유로 같은 시간에 바뀌는 클래스를 같은 컴포넌트로 묶기
서로 다른 이유로 다른 시간에 바뀌는 클래스를 다른 컴포넌트로 묶기
단일 책임 원칙이 컴포넌트 단위로 확장된 것
단일 클래스의 변경 이유가 하나이듯
단일 컴포넌트의 변경 이유도 하나여야 한다
유지 보수성이 몹시 중요한데 변경이 이루어진다면 컴포넌트 하나의 단위에서 모든 변경이 일어나는 것이 낫다
이 원칙은 개방 폐쇄 원칙과도 연결
개방 폐쇄 원칙과 공통 폐쇄 원칙의 폐쇄는 같은 뜻

공통 재사용의 원칙
컴포넌트 사용자들을 필요하지 않은 것들에 의존하도록 강요하지 말 것
클래스와 모듈을 어느 컴포넌트에 위치시킬 것인지 선택하는 역할
대개 같은 모듈의 재사용성이 높은 클래스는 같은 모듈의 다른 클래스와의 의존성이 높고 이것은 의존성을 줄일 수 없음
중요한 것은 어느 클래스를 묶지 말아야 하는지 결정하는 것
또한 이것은 컴포넌트 단위의 인터페이스 분리 원칙이라고 한다

재사용/릴리스 등가원칙, 공통 폐쇄 원칙은 컴포넌트를 크게 함
공통 재사용의 원칙은 컴포넌트를 작게 함
재사용성과 개발가능성이라는 서로 대립되는 가치 중에 어느 것에 중점을 두느냐

14 컴포넌트 결합
의존성 비순환 원칙 ADP

컴포넌트 의존성 그래프에 순환이 있어서는 안된다

개발환경을 릴리스 가능한 컴포넌트 단위로 분리
컴포넌트의 의존성 구조를 따라가면 최초의 컴포넌트가 나와서는 안 됨
의존성 방향은 한쪽으로 일방적으로 흘러감
순환이 발생하는 순간 거대한 컴포넌트가 발생하고 이를 관리하기 쉽지 않아진다는 점도 있다
이 순환을 끊으려면 의존성 역전 원리를 사용하기 - 이 책의 예시에선 인터페이스를 써서 관리
순환에 쓰이는 컴포넌트 모두 의존하는 새 컴포넌트 만들어 분리하기

의존성 구조에서 중요한 것은 변동성 분리
컴포넌트 의존성 구조는 시스템이 성장하면서 논리적인 설계에 맞춰 같이 발달

안정된 의존성 원칙

안정성의 방향으로 의존

바꾸기 쉽지 않은 모듈이 바뀌기 쉬운 모듈에 의존하는 상황을 만들지 말 것
안정성
책임지는 것(의존되는 것)이 많아질 수록 안정성이 높아야 함
안정성을 평가하는 지표
Fan-in : 안으로 들어오는 의존성
Fan-out : 밖으로 나가는 의존성
불안정성 I = Fan-out/(Fan-in+Fan-out)
I가 0이면 안정적, 1이면 불안정

C++에서는 #include
java에서는 import를 통해 의존성을 표현

안정적인 컴포넌트가 많으면 변경이 어렵고 소프트웨어 답지 않음
불안정한 컴포넌트에 대한 의존성을 끊는 방법은 DIP 의존성 역전 즉 인터페이스를 도입하는 것
java나 C#에서 쓸 수 있음

안정된 추상화 원칙
컴포넌트는 안정된 만큼 추상화되어야 함

고수준 아키텍쳐 - 업무로직 같은 것들은 변동성이 적어야 함
컴포넌트가 안정적이면서도 변경에 대응하려면?
개방폐쇄원칙으로 작성할 것 : 추상클래스를 활용하기

안정적인 컴포넌트는 인터페이스, 추상클래스로 구성 혹은 의존성을 갖고 있어 확장되기 쉬워야 함
의존성은 추상에 기댈 것

추상화 정도 : (컴포넌트의 추상클래스 갯수 +인터페이스 갯수)/컴포넌트 클래스 갯수
0과 1사이의 값을 가짐 0이면 추상클래스가 없음, 1이면 모든 것이 추상클래스로 되어 있음

안정성과 추상화의 관계에서
고통의 구역-바뀌면 큰 고통을 초래하는 구역
쓸모없는 영역- 다른데서 쓰이는 곳이 없는 죽은 코드
영역에서 벗어난 주계열 영역에 자리 잡아야 함

D라는 평가 지표가 있는데 이런 주 계열과의 거리를 측정하는 것으로
D가 0이면 주계열, 1이면 주계열 바깥
