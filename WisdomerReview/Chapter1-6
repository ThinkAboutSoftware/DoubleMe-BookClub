
Chapter1 설계Design vs 구조/뼈대Architecture

구조 : 보다 고차원의 무언가
설계 : 저 수준의 구조 또는 결정사항
저자는 큰 틀에서 보아 결국 차이가 없다는 점을 강조한다.
둘은 커다란 틀로 보아 결국 둘 다 소프트웨어의 구조를 결정하는데 영향을 주고 엄밀히 구분되지 않음을 이야기 하고 있다.
보다 중요한 것은 저 둘의 목적이라는 것이다.
그리고 저자는 아주 간단한 시장경제의 원리로 독자들을 설득한다.

소프트웨어 아키텍쳐, 혹은 설계의 목적은 필요한 시스템을 유지, 보수하는데 들이는 인력을 최소화 하는 것

그리고 이에 대한 예시들을 몇 가지 사례 (유지 보수 인원과 비용은 늘어나지만 생산성은 바닥을 기는 현상)를 통해 이야기하고 있다.
그리고 저자는 여기서 소프트웨어 아키텍쳐의 중요성을 이야기 한다.
빨리 가는 유일한 방법은 제대로 가는 것이다 < 이 책의 주요 목적이 이것이 아닐까 한다.

제대로 가기 위한 설계, 구조가 좋은 아키텍쳐가 아닐까?라는 생각할 거리를 던져주는 단원이다.

Chapter2 두 가지 가치 : 행위Behaviour, 구조Structure

소프트웨어 시스템이 제공하고자 하는 두 가치가 행위와 구조라고 이야기 하며
대부분의 개발자가 행위에 집중하여(제공하는 서비스 등) 요구사항을 만족시키는데 집중하기만 한다고 지적한다.(물론 나도 그런 사람 중에 하나 같다)
하지만 또다른 중요한 가치 소프트웨어-즉 부드럽기 때문에 다른 요구사항들이 쉽게 반영되어 빠르게 변경될 수 있는 것이어야 한다고 한다.

저자는 비용 증가의 커다란 문제가 저 변경이 쉬운 특성과 변경의 범위와 형태의 차이에서 비롯된다고 주장한다.

그리고 대부분의 개발자들은 행위가 잘 되는 것에만 집중하여 변경이 어려워지는 코드를 만들기 쉬워진다고 한다.
물론 이는 소프트웨어에 걸맞지 않은(부드럽지 않은) 것이라고 저자는 주장한다.

행위는 긴급하나 중요도가 떨어지고 구조는 중요하나 긴급성이 떨어진다고 한다.

급히 해야 할 일에 몰려 시야가 좁아진 나를 반성한다.

Chapter3 패러다임 : 구조적 프로그래밍Structural Programming, 객체 지향 프로그래밍Object-Oriented Programming, 함수형 프로그래밍Functional Programming

구조적 프로그래밍은 제어 흐름의 직접적인 전환에 대한 규칙을 부여하는것 
객체 지향 프로그래밍은 제어 흐름의 간접적인 전환에 대한 규칙을 부여하는 것
함수형 프로그래밍은 할당문에 대한 규칙을 부여하는 것

이 세가지 방식 모두 프로그래머에게서 특정 권한을 박탈하는 것이 있다고 한다.
저자는 여기서 박탈되는 것이 있음을 인지하는 것이 중요하다고 주장한다.

프로그래머에게 쉽게 짤 수 있는 권한을 부여하는 방식인줄 알았던 패러다임이 오히려 우리에게서 권한을 빼앗아 가는 방식이라는 접근은 매우 생소하게 다가왔다.
보다 짜기 쉽게 하기 위해 패러다임들이 적용된 줄 알았으나 시야를 달리하여 오히려 좋은 방식을 권장하며 권한을 빼앗아 가는 것이 아닐까?라는 생각할 거리를 안겨주었다.

Chapter4 구조적 프로그래밍

데이크스트라는 분기와 반복이라는 단순한 제어 구조가 좋은 goto문의 활용이라는 것을 눈치채고 해당 구조는 순차 실행의 방법과 연결되었을 때 더 효과적이라는 것을 깨달았다고 한다.
뵙과 야코파니가 모든 프로그램은 순차, 분기, 반복이라는 간단한 세 가지 구조로 표현될 수 있음을 증명하였다고 한다.
모듈로 분해될 수 있는 구조단위가 프로그램을 만들 수 있는 제어 구조의 최소단위와 일치함을 수학적으로 증명하였다고 하니 정말로 수학이 학문의 기초라는 것을 다시금 깨닫게 된다.

goto문은 이 증명의 단계에서 프로그램의 세계에서 퇴출되어 현대적인 대다수의 프로그래밍 언어에서 지원이 끊겼다고 한다.
현재는 모두 구조적인 프로그래밍의 지배하에 놓여있다고 하니 순차적으로 진행되는 프로그래밍 언어의 논리 전개 방식이 정립된 것인가 하는 생각도 들었다.

다만 저자는 수학적으로 증명하려던 모든 시도는 결국 사라지고 과학적인 반증이 없는 (증명할 수는 없지만 효율은 있는) 방법을 쓰게 되었다고 이야기한다.

Chapter5 객체지향 프로그래밍
캡슐화, 상속, 다형성이 객체지향의 필수, 혹은 지원요소인가?

캡슐화는 결국 숨기기 프로그램 언어에서 private이라는 키워드로 제공되는 것들(숨기기)인데 이는 객체지향이 아니더라도 가능하다고 저자는 강조한다.
C언어(객체지향 프로그램 언어라고 하지 않는)의 예시를 들며 여기서도 캡슐화가 진행된다고 이야기하며(접근성의 문제)
또한 오히려 C++, C#, java로 오며 캡슐화가 더 깨졌다고 이야기한다.

객체 지향 이야기 할 때 많이 나오던 캡슐화의 내용이 사실은 그렇지 않았다는 것부터 몹시 생소하게 다가왔다. 그럼 다른 사람들은 그리고 나는 왜 그렇게 알고 있던 것일까?
하는 생각할 거리가 늘었다.

상속만큼은 객체지향 언어가 지원하였다고 이야기 한다.
하지만 이 역시 사실이 아니었다고 한다. 역시 저자는 C언어의 예시를 들었다.
객체지향 언어가 상속이라는 개념 자체를 새로 생성한 것은 아니지만 편리성은 주었다고 한다.

다형성 역시 C언어에서도 표현할 수 있다고 한다.
함수를 가리키는 포인터를 응용한 것이 다형성의 시작이라고 하니 다형성도 객체지향 언어만의 특징은 아니었던 것이다.
단지 함수를 가리키는 포인터의 활용은 몹시 위험하고 버그를 찾기 어렵다고 지적한다. 다형성의 표현이 쉬운 것만은 아니었던 것은  분명하다.

다만, 다형성을 안전하고 쉽게 표현할 수 있게 되었다는 부분이 차이가 있다고 한다.

얼기설기 들었던 지식이 파괴되는 순간이다. 객체 지향 언어이기 때문에 가능한 것이라고 주장했던 개념들이 하나같이 그것이 아니었다.
그렇다면 객체지향 언어는 저 요소들을 보다 사람들이 쓰기 쉽게, 고치기 쉽게 바꾼 것인가? 그럼 그것만으로도 가치가 있는 것이 아닌가 하는 생각이 들었다.
다만 객체지향 언어이기 때문에 저것들이 가능해라는 것은 아니라는 사실은 쉽게 잊지 못할 것 같다.

다형성이 중요한 것은 부드럽게 적용되기 쉬운 것(플러그인 등)이기 때문이라고 한다.
장치에 독립적인 프로그래밍 : 현재 내가 쓰고 있는 엔진이나 언어도 그것을 목표로 계속 개선되는 것이 아닌가.
결국 프로그래밍의 목적은 예전이나 지금이나 크게 다르지 않다 생각이 들었다.

저자가 강조하는 객체 지향 언어의 강점은 다형성을 쉽게 제공하므로 어디서든 소스코드 의존성을 역전(제어 흐름과 소스코드 의존성이 반대로 움직이는 것)시킬 수 있는 부분이다.
그리고 이 강점은 배포 독립성, 개발 독립성이라는 또다른 강점을 제공한다고 한다.

캡슐화, 상속이 아닌 다형성을 안전하고 쉽게 제공하여 거기서 발생되는 소스코드 의존성의 역전이 객체 지향 언어의 힘이었던 것이다.

Chapter 6 함수형 프로그래밍
함수형 프로그래밍의 핵심은 람다 계산법이라 한다.

책에서는 사례들을 통해 그 예시들을 들고 있다.
또한 가변 변수가 아닌 함수형 프로그래밍은 모든 변수가 변경되지 않는다고 한다.

프로그래밍에서 중요한 에러 경합, 교착상태, 동시업데이트 모두 가변 변수의 값을 바꾸면서 발생되거나 발생할 수 있는 문제들인데 함수형 프로그래밍에서는 이와 같은 일이 발생할 일이 없다는 것이다.
하지만 프로세서의 속도가 몹시 빠르고 저장공간이 무한히 커야 한다고 하니, 이 역시 일부 제한적인 부분이 있는 것 같다.

어플리케이션 내부에서 불변, 가변으로 나누어 불변에는 최대한 많이, 가변은 최대한 적게 하는 것이 좋다고 한다.

그렇다면 이것은 우리가 개발하는 프로그램에 대입해서 생각해보면 변치 않는 부분들은 상수로 처리하여 프로그래밍을 하는 것이 좋은 것이 아닌가? 하는 생각도 들게 되었다.

이벤트 소싱은 트렌젝션(요청사항)을 저장하여 상태가 아닌 요청들만 저장하여 실제로는 저장될 때 변수등이 바뀌는 것이 하나 없이 요청사항들의 순서들만 저장되어 그 실행을 진행한다고 하니
예전에 개발팀에서 커맨드-? 분리 개념이 떠올랐다.
