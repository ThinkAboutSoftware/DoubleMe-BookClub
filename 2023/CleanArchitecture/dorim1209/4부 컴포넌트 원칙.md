# 12장 컴포넌트

- 컴포넌트는 배포 단위다. 컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다.
- 런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다.

# 13장 컴포넌트 응집도

- 컴포넌트 응집도와 관련된 세 가지 원칙
- REP(Reuse/Release Equivalence Principle): 재사용/릴리스 등가 원칙
  - 재사용 단위는 릴리스 단위와 같다.
  - 단일 컴포넌트는 응집성이 높은 클래스와 모듈들로 구성되어야 함을 뜻한다.
  - 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 한다.
- CCP(Common Closure Principle): 공통 폐쇄 원칙
  - 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.
  - 공통 폐쇄 원칙은 단일 책임 원칙을 컴포넌트 관점에서 다시 쓴 것이다.
  - 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안 된다고 말한다.
  - CCP는 컴포넌트 수준의 SRP다.
  - 동일한 시점에 동일한 이유로 변경되는 것들을 한테 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.
- CRP(Common Reuse Principle): 공통 재사용 원칙
  - 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.
  - 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다. 바꿔 말하면, 한 컴포넌트에 속한 클래스들은 더 작게 그룹지을 수 없다. 즉, 그중 일부 클래스에만 의존하고 다른 클래스와는 독립적일 수 없음을 확실히 인지해야 한다.
  - CRP는 인터페이스 분리 원칙의 포괄적인 버전이다.
- 컴포넌트 응집도에 대한 균형 다이어그램
  ![145679950-6d46552b-e2f1-40ca-a0a8-9e0a7b87270e.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/89e51f18-69ad-43cf-a722-0fa3646776b2/145679950-6d46552b-e2f1-40ca-a0a8-9e0a7b87270e.png)
  - 오로지 REP와 CRP에만 중점을 두면, 사소한 변경이 생겼을 때 너무 많은 컴포넌트에 영향을 미친다. 반대로 CCP와 REP에만 과도하게 집중하면 불필요한 릴리스가 너무 빈번해진다.
  - 프로젝트 초기에는 CCP가 REP보다 훨씬 중요한데, 개발 가능성이 재사용성보다 더욱 중요하기 때문이다.
  - 시간의 흐름에 따라 프로젝트의 초점이 개발가능성에서 재사용성으로 바뀌고, 그에 따라 컴포넌트를 구성하는 방식도 조금씩 흐트러지고 또 진화한다.

# 14장 컴포넌트 결합

- ADP: 의존성 비순환 원칙
  - 컴포넌트 의존성 그래프에 순환이 있어서는 안 된다.
  - 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리해라. 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다.
  - 컴포넌트가 새로 릴리스되어 사용할 수 있게 되면, 다른 팀에서는 새 릴리스를 당장 적용할지를 결정해야 한다.
  - 컴포넌트 사이의 의존성 구조를 반드시 관리해야 한다. 의존성 구조에 순환이 있어서는 안 된다.
  - 시스템 전체를 리리스해야 할 때가 오면 릴리스 절차는 상향식으로 진행된다.
  - 순환이 생기면 컴포넌트를 분리하기가 상당히 어려워진다.
  - 의존성 그래프에 순환이 생기면 컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기가 상당히 힘들어진다.
  - 컴포넌트 사이의 순환을 끊고 의존성을 다시 DAG로 원상복구하는 일은 언제라도 가능하다.
  - 의존성 역전 원칙을 적용한다. 의존하는 새로운 컴포넌트를 만든다.
  - 요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다.
  - 의존성 구조에 순환이 발생하는지를 항상 관찰해야 한다. 순환이 발생하면 어떤 식으로든 끊어야 한다.
- 하향식(top-down) 설계
  - 컴포넌트 구조는 하향식으로 설계될 수 없다. 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 떄 함께 진화한다.
  - 의존성 구조와 관련된 최우선 관심사는 변동성을 격리하는 일이다.
- SDP: 안정된 의존성 원칙
  - 안정성의 방향으로(더 안정된 쪽에) 의존하라.
  - 당신이 모듈을 만들 때는 변경하기 쉽도록 설계했지만, 이 모듈에 누군가가 의존성을 매달아 버리면 당신의 모듈도 변경하기 어려워진다.
  - 소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다. 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적이라고 볼 수 있는데, 사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하려면 상당한 노력이 들기 때문이다.
  - 어떻게 하면 컴포넌트의 안정성을 측정할 수 있을까? 컴포넌트로 들어오고 나가는 의존성의 개수를 세어보는 방법이 있을 수 있다.
  - 모든 컴포넌트가 최고로 안정적인 시스템이라면 변경이 불가능하다.
    - 다이어그램에서 불안정한 컴포넌트를 관례적으로 위쪽에 두는데, 이 관례를 따름련 상당히 유용하다. 위로 향하는 화살표가 있으면 SDP를 위배하는(그리고 나중에 보겠지만 ADP도 위반하는) 상태가 되기 때문이다.
- SAP: 안정된 추상화 원칙
  - 컴포넌트는 안정된 정도만큼만 추상되어야 한다.
  - 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다. 안정된 컴포넌트가 확장이 가능해지면 유연성을 얻게 되고 아키텍처를 과도하게 제약하지 않게 된다.
- 의존성 관리 지표는 설계의 의존성과 추상화 정도가 내가 ‘훌륭한’ 패턴이라고 생각하는 수준에 얼마나 잘 부합하는지를 측정한다. 하지만 지표는 신이 아니다. 지표는 그저 임의로 결정된 표준을 기초로 한 측정값에 지나지 않는다. 하지만 이들 지표로부터 무언가 유용한 것을 찾을 수 있기를 바란다.
