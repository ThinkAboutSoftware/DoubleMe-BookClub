## 12장 컴포넌트

컴포넌트는 배포 단위다.
컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다.

컴포넌트가 마지막에 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한,
따라서 독립적으로 개발 가능한 능력을 갖춰야 한다.

### 컴포넌트의 간략한 역사

소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어했다.
컴파일러는 느린 장치를 이용해서 소스 코드를 여러 차례 읽어야만 했다.
함수 라이브러리가 크면 클수록 컴파일은 더 오래 걸렸고, 대규모 프로그램을 컴파일하는 데는 몇 시간씩 걸리곤 했다.

프로그래머가 함수 라이브러리에 더 많은 함수를 추가하면 이 역시 할당된 메모리 주소를 넘어서게 되고,
결국 추가 공간을 할당해야한다.
프로그램과 라이브러리가 사용하는 메모리가 늘어날수록 이와 같은 단편화는 계속될 수밖에 없었다.

### 재배치성

해결책은 재배치가 가능한 바이너리relocatable binary였다.
로더를 통해 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하는 아이디어이다.

프로그래머는 로더를 통해 함수 라이브러리와 애플리케이션을 로드할 위치를 지시할 수 있게 되었다.
로더는 여러개의 바이너리를 입력받은 후, 하나씩 차례로 메모리에 로드하면서 재배치하는 작업을 처리했다.

라이브러리 함수를 정의하는 프로그램이면 컴파일러는 해당 이름을 외부 정의external definition로 생성했다.
외부 정의를 로드할 위치가 정해지기만 하면 로더가 외부 참조를 외부 정의에 링크시킬 수 있게 된다.
이렇게 링킹 로더linking loader가 탄생했다. 

### 링커

링킹 로더의 등장으로 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었다.
프로그램이 커지고 링킹 로더가 느려지게 되면서 두 단계로 분리되었다.
링커linker라는 별도의 애플리케이션으로 링크 작업을 처리하게 만들었다.

무어의 법칙으로 디스크는 작어지고 빨라졌고, 메모리는 저렴해지고 디스크에 저장된 데이터를 RAM에 캐싱할 수 있게 되었다.
컴퓨터 클록 속도도 증가했다.
링크 시간이 줄어드는 속도가 초 단위 수준이 될 정도로 감소했다.

로드와 링크를 동시에 할 수 있을 정도로 컴퓨터가 빨라져서
.jar 파일이나 공유 라이브러리를 순식간에 서로 링크한 후, 링크가 끝난 프로그램을 실행할 수 있게 되었다.
이렇게 컴포넌트 플러그인 아키텍처component plugin architecture가 탄생했다.

### 결론

런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 소프트웨어 컴포넌트에 해당한다.