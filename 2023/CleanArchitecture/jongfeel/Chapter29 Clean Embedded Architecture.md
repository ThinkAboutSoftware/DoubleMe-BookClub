## 29장 클린 임베디드 아키텍처

더그 슈미트Doug Schmidt의 블로그에서 한 주장

> 소프트웨어는 닳지 않지만, 펌웨어와 하드웨어는 낡아 가므로 결국 소프트웨어도 수정해야 한다

여기에 다음과 같이 더 덧붙인다.

> 소프트웨어는 닳지 않지만, 펌웨어와 하드웨어에 대한 의존성을 관리하지 않으면 안으로부터 파괴될 수 있다.

ROM에 상주하는 코드 혹은 저장되는 위치가 펌웨어를 정의하지는 않는다. 무엇에 의존하는지, 그리고 하드웨어 발전에 맞춰 수정하기가 얼마나 어려운지에 따라 정의된다. 하드웨어는 발전할 수밖에 없고, 그러한 현실을 염두에 두고 임베디드 코드를 구조화할 수 있어야 한다.

엔지니어와 프로그래머에게 전하는 메시지는 펌웨어를 수없이 양산하는 일을 멈추고, 코드에게 유효 수명을 길게 늘릴 수 있는 기회를 주어야 한다는 것이다.

### 앱-티튜드 테스트

임베디드 소프트웨어는 왜 펌웨어로 변하는가?
임베디드 코드가 동작하게 만드는 데 대부분의 노력을 집중하고, 오랫동안 유용하게 남도록 구조화하는 데는 그리 신경 쓰지 않기 때문이다.

켄트 벡Kent Beck은 "먼저 동작하게 만들어라"고 했고
프레드 브룩스Fred Brooks는 "버리기 위한 계획을 세우라"고 제안했다.
둘은 같은 충고를 하고 있다. 동작하는 것을 배워라 그리고 나서 더 나은 해결책을 만들어라.

임베디드가 아닌 코드들도 올바르게 작성해서 유효 수명을 길게 늘리는 데는 거의 관심 없이, 그저 동작하도록 만들어진다.
이건 개발자용 앱-티튜트 테스트App-titude test라고 부른다.
앱이 동작하도록 만드는 일만 신경 쓴다면 자신의 제품과 고용주에게 몸쓸 짓을 하는 것이다. 프로그래밍에는 단순히 동작하도록 만드는 것 보다 중요한 것이 훨씬 많다.

### 타깃-하드웨어 병목현상

임베디드가 지닌 특수한 문제 중 하나는 타깃-하드웨어 병목현상target-hardware bottleneck이다. 임베디드 코드가 클린 아키텍처 원칙과 실천법을 따르지 않고 작성된다면, 대개의 경우 코드를 테스트할 수 있는 환경이 해당 특정 타깃으로 국한될 것이다. 그리고 그 타깃이 테스트가 가능한 유일한 장소라면 타깃-하드웨어 병목현상이 발생하여 진척이 느려질 것이다.

#### 클린 임베디드 아키텍처는 테스트하기 쉬운 임베디드 아키텍처다

**계층**

하드웨어-펌웨어-소프트웨어의 계층 구조
하드웨어가 변경되는 시점이 오면 임베디드 엔지니어는 필요 이상의 작업을 하지 않도록 해야 한다. 그러기 위해서는 하드웨어가 정의된 이후 펌웨어와의 계층 분리를 잘 해야 한다.

소프트웨어와 펌웨어가 서로 섞이는 일은 안티 패턴이다. 가벼운 변경에도 시스템 전체를 대상으로 회귀 테스트를 전부 실행해야 한다.

**하드웨어는 세부사항이다**

소프트웨어와 펌웨어 사이의 경계는 잘 정의하기가 대체로 힘들다.
임베디드 소프트웨어 개발자가 해야 할 일 하나는 이 경계를 분명하게 만드는 것이다. 소프트웨어와 펌웨어 사이의 경계는 하드웨어 추상화 계층Hardware Abstraction Layer, HAL이라고 부른다.

HAL은 자신보다 위에 있는 소프트웨어를 위해 존재하므로, HAL의 API는 소프트웨어의 필요에 맞게 만들어져야 한다. 

#### HAL 사용자에게 하드웨어 세부사항을 드러내지 말라

클린 임베디드 아키텍처로 설계된 소프트웨어는 타깃 하드웨어에 관계없이 테스트가 가능하다. HAL을 제대로 만들었다면, HAL은 타깃에 상관 없이 테스트할 수 있는 경계층 또는 일련의 대체 지점을 제공한다.

**프로세서는 세부사항이다**

임베디드 애플리케이션의 특수한 툴 체임을 사용한다면 컴파일러는 C 언어를 제멋대로 변경하여 해당 업체의 프로세서 기능에 접근할 수 있는 새로운 키워드를 제공하곤 한다. 그렇게 되면 이 코드는 C처럼 보이겠지만, 더 이상 C가 아니다.

클린 임베디드 아키텍처라면 장치 접근 레지스터를 직접 사용하는 코드는 소수의, 순전히 펌웨어로만 한정시켜야 한다. 이들 레지스터를 알고 있는 것은 모두 펌웨어가 되어야 하며, 따라서 실리콘 칩에 종속된다.

마이크로 컨트롤러를 사용할 때, 펌웨어가 저수준 함수들을 프로세서 추상화 계층Processor Abstraction Layer, PAL의 형태로 격리시켜줄 수 있다. PAL 상위에 위치하는 펌웨어는 타깃-하드웨어에 관계없이 테스트할 수 있게 되어, 펌웨어 자체도 덜 딱딱해firm질 수 있다.

**운영체제는 세부사항이다**

HAL은 필수적이지만 이것 만으로 충분하지 않다. 임베디드 시스템에서 실시간 운영체제를 사용하거나 임베디드 버전의 리눅스/윈도우를사용한다면? 세부사항으로 취급하고 운영체제에 의존하는 일을 막아야 한다.

클린 임베디드 아키텍처는 운영체제 추상화 계층Operating System Abstraction Layer, OSAL을 통해 소프트웨어를 운영체제로 부터 격리시킨다.

![image](https://user-images.githubusercontent.com/17442457/229827860-9cb3232d-a067-40ee-9041-b503a476ae6e.png)

클린 임베디드 아키텍철르 따른 소프트웨어는 타깃 운영체제에 관계없이 테스트할 수 있다. 제대로 만든 OSAL은 타깃과는 별개로 테스트할 수 있도록 해주는 경계층 또는 일련의 대체 지점을 제공한다. 

#### 인터페이스를 통하고 대체 가능성을 높이는 방향으로 프로그래밍하라

계층형 아키텍처layered architecture는 인터페이스를 통해 프로그래밍하자는 발상을 기반으로 한다. 모듈들이 서로 인터페이스를 통해 상호작용한다면 특정 서비스 제공자를 다른 제공자로 대체할 수 있다.

구현 세부사항의 가시성을 제한하고 구현 세부사항은 변경될 거라고 가정하라. 세부사항을 알고 있는 부분이 적을수록 추적하고 변경해야 할 코드도 적어진다.

클린 임베디드 아키텍처에서는 모듈들이 인터페이스를 통해 상호작용하기 때문에 각각의 계층 내부에서 테스트가 가능하다.

#### DRY 원칙: 조건부 컴파일 지시자를 반복하지 말라

예로 `#ifdef BOARD_V2`와 같은 구분이 수천군데 사용된다면 엄청난 문제가 된다.

하드웨어 추상화 계층을 통해 조건부 컴파일 대신 사용할 수 있는 인터페이스를 제공한다면, 링커 또는 실시간 바인딩을 사용해서 소프트웨어를 하드웨어와 연결할 수 있다.

### 결론

임베디드 소프트웨어를 개발하는 사람들은 임베디드 소프트웨어 바깥의 경험에서 많은 것을 배울 수 있다.
모든 코드가 펌웨어가 되도록 내버려두면 제품이 오래 살아남을 수 없게 된다.
클린 임베디드 아키텍처는 제품이 장기간 생명력을 유지하는 데 도움을 준다.