## 16장 독립성

좋은 아키텍처는 다음을 지원해야 한다

- 시스템의 유스케이스
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포

### 유스케이스

시스템의 아키텍처는 시스템의 의도를 지원해야 한다.
시스템이 장바구니 애플리케이션이라면, 이 아키텍처는 장바구니와 관련된 유스케아스를 지원해야 한다.

좋은 아키텍처가 행위를 지원하기 위해 할 수 있는 일 중에서 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다.

### 운영

시스템의 운영 관점에서 아키텍처는 더 실질적이며 덜 피상적인 역할을 맡는다.

아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면, 시간이 지나 운영에 필요한 요구사항이 바뀌더라도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것이다.

### 개발

콘웨이의 법칙

> 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.

잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할한다면 컴포넌트를 독립적으로 작업할 수 있는 팀에 할당할 수 있다.

### 배포

좋은 아키텍처라면 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 한다.

### 선택사항 열어놓기

현실에서는 컴포넌트 구조와 관련된 관심사들 사이에 균현을 맞추고 관심사 모두를 만족시키기는 어렵다.
시스템이 생명주기의 단계를 하나씩 거쳐가면 우리가 도달하려는 목표가  뚜렷하지 않아서 시시각각 변한다.

이러한 변화 속에서도 사라지지 않는 몇몇 아키텍처 원칙이 있다.
시스템을 제대로 격리된 컴포넌트 단위로 분할할 때 도움이 되며, 이를 통해 선택사항을 가능한 한 많이, 그리고 가능한 한 오랫동안 열어둘 수 있게 해둔다.

### 계층 결합 분리

아키텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용하여, 그 의도의 맥락에 따라서 다른 이유로 변경되는 것들은 분리하고, 동일한 이유로 변경되는 것들은 묶는다.

데이터베이스, 쿼리 언어, 스키마조차도 기술적인 세부사항이며, 업무 규칙이나 UI와는 아무런 관련이 없다.
이들은 시스템의 다른 측면과는 다른 속도로, 그리고 다른 이유로 변경된다.
아키텍트는 이들을 시스템의 나머지 부분으로부터 분리하여 독럽적으로 변경할 수 있도록 해야만 한다.

### 유스케이스 결합 분리

시스템을 수평적 계층으로 분할하면서 동시에 해당 계층을 가로지르는, 얇은 수직적인 유스케이스로 시스템을 분할할 수 있다.

유스케이스를 뒷받침하는 UI와 데이터베이스를 서로 묶어서 각 유스케이스가 UI와 데이터베이스의 서로 다른 관점aspect을 사용하게 되면, 새로운 유스케이스를 추가하더라도 기존 유스케이스에 영향을 주는 일은 거의 없을 것이다.

### 결합 분리 모드

유스케이스에서 서로 다른 관점이 분리되었다면, 처리량을 보장해야 하는 유스케이스는 분리 되었을 것이고, UI와 데이터베이스가 업무 규칙과 분리되어 있다면 다른 서버에서 실행될 수 있다.

유스케이스를 위해 수행하는 결합 분리는 운영에 도움이 된다.
분리된 컴포넌트를 서로 다른 서버에서 실행해야 하는 상황이면, 독립된 서비스가 되어야 하고 네트워크를 통해 통신하게 해야 한다.

컴포넌트를 서비스 수준까지 분리하면 서비스 지향 아키텍처로 부를 수 있다.

좋은 아키텍처는 선택권을 열어둔다. 결합 분리 모드는 이러한 선택지 중 하나다.

### 개발 독립성

기능 팀, 컴포넌트 팀, 계층 팀, 혹은 또 다른 형태의 팀이라도, 계층과 유스케이스의 결합이 분리되는 한 시스템의 아키텍처는 그 팀 구조를 뒷받침해 줄 것이다.

### 배포 독립성

결합을 제대로 분리했다면 운영 중인 시스템에 계층과 유스케이스를 교체할 수 있다.
새로운 유스케이스를 추가하는 일은 새로운 jar 파일 혹은 서비스 몇 개를 추가하는 일이 된다.

### 중복

우발적 중복은 중복으로 보이는 두 코드가 각자 경로로 발전하면 진짜 중복이 아니게 된다.
우발적 중복 코드는 나중에는 다른 모습으로 발전하므로, 처음부터 중복이라 생각해서 통합하지 않도록 주의해야 한다.
나중에 코드를 다시 분리하느라 큰 수고를 감수해야 한다.

### 결합 분리 모드 (again)

계층과 유스케이스의 결합을 분리하는 방법은 다양하다.

- 소스 수준 분리 모드: 소스 코드 모듈 사이의 의존성을 제어할 수 있다. 하나의 모듈이 변경되어도 다른 모듈을 변경하거나 재컴파일 하지 않도록 만들 수 있다.
- 배포 수준 분리 모드: jar, dll 공유 라이브러리와 같이 배포 가능한 단위들 사이의 의존성을 제어할 수 있다. 한 모듈이 변경되어도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들 수 있다.
- 서비스 수준 분리 모드: 의존 수준을 데이터 구조 단위까지 낮출 수 있고, 네트워크 패킷을 통해서만 통신하도록 만들 수 있다. (예, 서비스 또는 마이크로서비스)

프로젝트 초기 단계는 어떤 모드가 최선인지 알기 어렵다.
프로젝트가 성숙해갈수록 최적인 모드가 달라질 수 있다.

좋은 아키텍처는 시스템이 모노리틱 구조로 태어나서 단일 파일로 배포되더라도, 이후에는 독립적으로 배포 가능한 단위들의 집합으로 성장하고, 또 독립적인 서비스나 마이크로서비스 수준까지 성장할 수 있도록 만들어져야 한다.
나중에 상황이 바뀌었을 때 이 진행 방향을 거꾸로 돌려 원래 형태인 모노리틱 구조로 되돌릴수도 있어야 한다.

좋은 아키텍처는 이러한 변경으로부터 소스 코드 대부분을 보호한다.
좋은 아키텍처는 결합 분리 모드를 선택사항으로 남겨두어서 배포 규모에 따라 가장 적합한 모드를 선택해 사용할 수 있게 만들어준다.

### 결론

시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉬우며, 뛰어난 아키텍트라면 이러한 변경을 예측하여 큰 무리 없이 반영할 수 있도록 만들어야 한다.