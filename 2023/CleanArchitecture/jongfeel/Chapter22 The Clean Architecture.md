## 22장 클린 아키텍처

아래 시스템 아키텍처 여러 아이디어 들은 세부적인 면은 차이가 있어도 같은 목표를 가지는데 관심사의 분리separation of concerns다.

- Hexagonal Architecture
- DCI(Data, Context and Interaction)
- BCE(Boundary-Conyrol-Entity)

위의 아키텍처는 모두 시스템이 다음과 같은 특징을 지니도록 만든다.

- 프레임워크의 독립성
- 테스트 용이성
- UI 독립성
- 데이터베이스 독립성
- 모든 외부 에이전시에 대한 독립성

![image](https://user-images.githubusercontent.com/17442457/228174224-da7499fb-f51a-4134-8524-53a7c1940ce4.png)

### 의존성 규칙

위 동심원에서 안으로 들어갈수록 고수준의 소프트웨어가 된다. 바깥쪽 원은 매커니즘이고, 안쪽 원은 정책이다.
이런 아키텍처가 동작하도록 하는 중요한 규칙은 의존성 규칙Dependency Rule이다.

> 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.

#### 엔티티

엔티티는 전사적인 핵심 업무 규칙을 캡슐화한다. 엔티티는 메서드를 가지는 객체이거나 일련의 데이터 구조와 함수의 집합일 수도 있다.

전사적이지 않은 단순한 단일 애플리케이션을 작성하고 있다면 엔티티는 해당 애플리케이션의 업무 객체가 된다.
운영 관점에서 특정 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어서는 안 된다.

#### 유스케이스

유스케이스 계층의 소프트웨어는 애플리케이션의 특화된 업무 규칙을 포함하고 시스템의 유스케이스를 캡슐화하고 구현한다.
엔티티로 들어오고 나가는 데이터 흐름을 조정하며, 엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스의 목적을 달성하도록 이끈다.

#### 인터페이스 어댑터

MVC 아키텍처를 포괄해서 프레젠터Presenter, 뷰View, 컨트롤러Controller 모두 인터페이스 어댑터 계층에 속한다.

이 안에 속한 코드는 데이터베이스에 대해 알아서는 안된다.
이 계층에는 데이터를 외부 서비스와 같은 외부적인 형식에서 유스케이스나 엔티티에서 사용되는 내부적인 형식으로 변환하는 또 다른 어댑터가 필요하다.

#### 프레임워크와 드라이버

이 계층은 안쪽원과 통신하기 위한 접합 코드 외에는 특별히 더 작성해야 할 코드가 많지 않다. 프레임워크와 드라이버 계층은 모든 세부사항이 위치하는 곳이다.

#### 원은 네 개여야만 하나?

네 개보다 더 많은 원이 필요할 수도 있고, 항상 네 개만 사용해야 한다는 규칙은 없다.
어떤 경우에도 의존성 규칙은 적용된다.

#### 경계 횡단하기

제어 흐름과 의존성의 방향이 명백히 반대여야 하는 경우, 대체로 의존성 역전 원칙을 사용하여 해결한다.
동적 다형성을 이용하여 소스 코드 의존성을 제어흐름과는 반대로 만들 수 있고, 이를 통해 제어흐름이 어느 방향으로 흐르더라도 의존성 규칙을 준수할 수 있다.

#### 경계를 횡단하는 데이터는 어떤 모습인가

격리되어 있는 간단한 데이터 구조가 경계를 가로질로 전달된다. 데이터 구조가 의존성을 가져서 의존성 규칙을 위배하게 되는 일은 바라지 않는다.
경계를 가로질러 데이터를 전달할 때, 데이터는 항상 내부의 원에서 사용하기에 편리한 형태를 가져야 한다.

### 전형적인 시나리오

![image](https://user-images.githubusercontent.com/17442457/228190221-70ec135a-6a8b-41dc-aca1-4ba680f80519.png)

### 결론

소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 될 것이며, 그에 따른 이점을 누릴 수 있다.