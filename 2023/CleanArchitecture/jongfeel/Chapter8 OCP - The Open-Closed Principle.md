## 8장 OCP: 개방-폐쇄 원칙

개방-폐쇄 원칙OCP이라는 용어는 1988년에 버트란트 마이어Bertand Meyer가 만들었다.

> 소프트웨어 개체artifact는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.

소프트웨어 아키텍처를 공부하는 가장 근본적이 이유이다.
요구사항을 살짝 확장하는 데 소프트웨어를 엄청나게 수정해야 한다면,
그 소프트웨어 시스템을 설계한 아키텍트는 엄청난 실패에 맞닥뜨린것이다.

### 사고 실험

재무제표를 웹 페이지로 보여주는 시스템의 예제.
웹 페이지에 표시되는 데이터는 스크롤할 수 있고, 음수는 빨간색으로 출력한다.

이걸 보고서 형태로 변환해서 흑백 프린터로 출력해 달라는 요청이 있다.

- 페이지 번호
- 페이지 마다 머리글 바닥글
- 표의 각 열에는 레이블이 있어야 함
- 음수는 괄호로 감싸야 함

코드를 수정한다고 했을 때 얼마나 많이 수정해야 할까?

단일 책임 원칙SRP을 적용하면 재무 데이터를 검사한 후 보고서용 데이터를 생성한 다음, 필요에 따라 두 가지 보고서 생성 절차 중 하나를 거쳐 적절히 포매팅한다.
여기서 얻을 수 있는 중요한 영감은 보고서 생성이 두 개의 책임으로 분리된다는 사실이다.

이렇게 두 책임으로 분리했다면 하나에서 변경이 발생해도 다른 하나는 변경되지 않도록 소스 코드 의존성도 확실히 조직화해야 한다.
또한, 새로 조직화한 구조에서는 행위가 확장될 때 변경이 발생하지 않음을 보장해야 한다.

아키텍트는 기능이 어떻게how, 왜why, 언제when 발생하는지에 따라서 기능으 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다.
컴포넌트 계층구조를 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.

### 방향성 제어

컴포넌트간 의존성의 방향은 의존성을 역전시키기 위해 필요하다.

### 정보 은닉

추이 종속성: 클래스 A가 클래스 B에 의존하고, 다시 클래스 B가 클래스 C에 의존한다면, 클래스 A는 클래스 C에 의존하게 되는 것.

추이 종속성을 가지게 되면, 소프트웨어 엔티티는 '자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다'는 소프트웨어 원칙을 위반하게 된다.
Controller에서 발생한 변경으로 부터 Interator를 보호하는 일의 우선순위가 가장 높지만,
반대로 Interator에서 발생한 변경으로부터 Controller도 보호되기를 바란다.
이를 위해 Interator 내부를 은닉한다.

### 결론

OCP는 시스템의 아키텍처를 떠받치는 원동력 중 하나다.
OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다. 
이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터
고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.