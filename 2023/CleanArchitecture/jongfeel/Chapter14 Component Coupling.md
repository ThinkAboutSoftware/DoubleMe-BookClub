## 14장 컴포넌트 결합

개발 가능성과 논리적 설계 사이의 균형
컴포넌트 구조와 관련된 아키텍처를 침범하는 힘은 기술적이며, 정치적이고, 가변적이다.

### ADP: 의존성 비순환 원칙

> 컴포넌트 의존성 그래프에 순환cycle이 있어서는 안 된다.

'숙취 증후군(the morning after syndrome)'은 많은 개발자가 동일한 소스 파일을 수정하는 환경에서 발생한다.
안정 버전을 빌드하지 못한 채 몇 주가 그냥 흘러가 버리는 일도 있고
망가진 부분이 동작하도록 만들기 위해 코드를 수정하고 또 수정하는 작업만이 계속된다.

이를 해결하기 위해

- 주 단위 빌드
- 의존성 비순환 원칙

이 있다.

#### 주 단위 빌드(Weekly Build)

첫 4일 동안 작업을 진행하고 금요일 마지막 날에 코드를 모두 통합하여 시스템을 빌드하는 작전.
프로젝트가 커지면 금요일 하루 만에 끝마치는게 불가능해진다.
통합에 드는 시간이 늘어나면서 효율성이 나빠진다.

```
의견)
짧은 한 페이지를 읽어 나가면서 왜 일일 빌드 얘기가 안나오는지 의문이 든다.
결국 주 단위 빌드의 문제점을 해결하기 위해서는 일일 빌드,
아니면 아예 merge and build가 제일 깔끔하고 효율적이다.
```

#### 순환 의존성 제거하기

이 문제의 해결책은 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것이다.
컴포넌트 단위로 분리해서 개발하고 새 릴리스를 했을 때 사용할지 말지를 결정하면서 진행한다.
특정 컴포넌트가 변경되더라도 다른 팀에 영향을 주지는 않는다.
통합은 작고 점진적으로 이뤄진다.

이 작업은 단순하고 합리적이어서 널리 사용되는 방식이다.
성공적으로 동작하기 위해서는 컴포넌트 사이의 의존성 구조를 반드시 관리해야 한다.

의존성 구조를 순환이 없게 작업해서 비순환 방향 그래프Directed Acyclic Graph, DAG가 되게 만들어야 한다.
구성 요소간 의존성을 파악하고 있으면 시스템을 빌드하는 방법을 알 수 있다.

#### 순환이 컴포넌트 의존성 그래프에 미치는 영향

컴포넌트 사이에 순환 결합이 발생하면 문제가 될 뿐만 아니라 받아들이기 어려워진다.
순환이 생기면 컴포넌트를 분리하기가 상당히 어려워진다.
단위 테스트를 하고 릴리스를 하는 일도 굉장히 어려워지며 에러도 쉽게 발생한다.
모듈의 개수가 많아짐에 따라 빌드 관련 이슈는 기하급수적으로 증가한다.

#### 순환 끊기

컴포넌트 사이의 순환을 끊고 의존성을 다시 원상복구 하는 일에는 주요 메커니즘 두 가지가 있다.

- 의존성 역전 원칙DIP을 적용한다.
- 순환을 끊고 순환을 끊은 컴포넌트들에 의존하는 새로운 컴포넌트를 만든다.

#### 흐트러짐(Jitters)

새로운 컴포넌트를 만든 후에 요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다.
의존성 구조가 서서히 흐트러지면서 성장하기 때문에 순환이 발생하는지를 항상 관찰해야 한다.

### 하향식(top-down) 설계

컴포넌트 구조는 하향식으로 설계될 수 없다.
컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다.

컴포넌트 의존성 다이어그램은 애플리케이션의 빌드 가능성buildability과 유지보수성maintainability을 보여주는 지도map와 같다.
빌드거하거나 유지보수할 소프트웨어가 없다면 빌드와 유지보수에 관한 지도 또한 필요 없기 때문에
컴포넌트 구조는 프로젝트 초기에 설계할 수 없다.

프로젝트 초기에 모듈들이 쌓이기 시작하면 의존성 관리에 대한 요구가 늘어가게 되고
변경되는 범위가 시스템의 가능한 한 작은 일부로 한정되기를 원한다.
단일 책임 원칙SRP과 공통 폐쇄 원칙CCP에 관심을 가지고 이를 적용해 함께 변경되는 클래스는 같은 위치에 배치되도록 만든다.

의존성 구조와 관련된 최우선 관심사는 변동성을 격리하는 일이다.
컴포넌트 의존성 그래프는 자주 변경되는 컴포넌트로부터 안정적이며 가치가 높은 컴포넌트를 보호하려는 아키텍트가 만들고 가다듬게 된다.

애플리케이션이 계속 성장함에 따라 재사용 가능한 요소를 만드는 일에 관심을 기울이기 시작한다.
컴포넌트를 조합하는 과정에서 공통 재사용 원칙CRP이 영향을 미치기 시작하고, 순환이 발생하면 ADP가 적용되고,
컴포넌트 의존성 그래프는 조금씩 흐트러지고 또 성장한다.

컴포넌트 의존성 구조는 시스템의 논리적 설계에 발맞춰 성장하며 또 진화해야 한다.

### SDP: 안정된 의존성 원칙

> 안정성의 방향으로(더 안정된 쪽에) 의존하라.

설계는 정적일 수 없다. 변경은 불가피하다.
컴포넌트 중 일부는 변동성을 지니도록 설계된다.

변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들면 안된다.
한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워진다.

모듈을 만들 때는 변경하기 쉽도록 설계했지만
누군가가 의존성을 매달아 버리면 변경하기가 어려워진다.

안정된 의존성 원칙Stable Dependencies Principle, SDP을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.

#### 안정성

소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다.
컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적이라고 볼 수 있는데,
사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하려면 상당한 노력이 들기 때문이다.

세 컴포넌트가 한 컴포넌트 X에 의존하면 X 컴포넌트는 변경하지 말아야 할 이유가 세가지가 된다.
이 경우 X는 세 컴포넌트를 책임진다reponsible라고 말한다.
X는 어디에도 의존하지 않으므로 X가 변경되도록 만들 수 있는 외적인 영향이 없다.
이 경우 X는 독립적이다independent라고 말한다.

![image](https://user-images.githubusercontent.com/17442457/223464083-4bf46d64-384f-4dae-9da6-0c51a3f5f11a.png)

#### 안정성 지표

컴포넌트의 안정성을 측정하기 위해 컴포넌트로 들어오고 나가는 의존성의 개수를 세어 보는 방법이 있을 수 있다.
이 숫자를 통해 컴포넌트가 위치상positional 어느 정도의 안정성을 가지는지 계산할 수 있다.

- Fan-in: 안으로 들어오는 의존성, 컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부의 클래스 개수
- Fan-out: 바깥으로 나가는 의존성, 컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부의 클래스 개수
- I(불안정성): I = Fan-out / (Fan-in + Fan-out). 이 지표는 0 ~ 1 범위의 값을 갖는다. 0에 가까우면 안정된 컴포넌트, 1에 가까우면 불안정한 컴포넌트라는 뜻이다.

I 값이 1이면 어떤 컴포넌트도 해당 컴포넌트에 의존하지 않지만(Fan-in = 0), 해당 컴포넌트는 다른 컴포넌트에 의존한다 (Fan-out > 0)
이 컴포넌트는 책임성이 없으며 의존적이다.
자신에게 의존하는 컴포넌트가 없으므로 변경하지 말아야 할 이유가 없다.

I값이 0이면 해당 컴포넌트에 의존하는 다른 컴포넌트가 있지만(Fan-in > 0), 해당 컴포넌트 자체는 다른 컴포넌트에 의존하지 않는다(Fan-out = 0)
이 컴포넌트는 다른 컴포넌트를 책임지며 또 독립적이다.
자신에게 의존하는 컴포넌트가 있으므로 해당 컴포넌트는 변경하기가 어렵지만,
해당 컴포넌트를 변경하도록 강제하는 의존성은 갖지 않는다.

#### 모든 컴포넌트가 안정적이어야 하는 것은 아니다

모든 컴포넌트가 안정적인 시스템이라면 변경이 불가능하다.
컴포넌트 구조를 설계할 때 기대하는 것은 불안정한 컴포넌트도 있고 안정된 컴포넌트도 존재하는 상태다.

불안정성을 유지하면서 컴포넌트 의존성을 끊으려면 DIP를 도입해 문제를 해결하는 방식으로 한다.

##### 추상 컴포넌트

인터페이스만을 포함하는 컴포넌트를 생성하는 방식의 추상 컴포넌트는 상당히 안정적이며 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상이다.

### SAP: 안정된 추상화 원칙

> 컴포넌트는 안정된 정도만큼만 추상화되어야 한다

#### 고수준 정책을 어디에 위치시켜야 하는가?

고수준 아키텍처나 정책 결정과 관련된 건 변경이 없어야 하므로 안정된 컴포넌트에 위치해야 한다.
불안정한 컴포넌트는 쉽고 빠르게 변경할 수 있는 소프트웨어만을 포함해야 한다.

고수준 정책을 안정된 컴포넌트에 위치시키면 소스 코드 수정이 어려워지고 아키텍처 유연성을 잃는다.
개방 폐쇄 원칙OCP을 통해 클래스를 수정하지 않고도 확장이 가능할 정도로 클래스를 유연하게 만든다.
추상 클래스를 통해 이 원칙을 준수한다.

#### 안정된 추상화 원칙

안정된 추상화 원칙Stable Abstractions Principle, SAP은 안정성과 추상화 정도 사이의 관계를 정의한다.
안정된 컴포넌트는 추상 컴포넌트로 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다.
불안정한 컴포넌트는 구체 컴포넌트여야 하고 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 한다.

안정적인 컴포넌트는 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 한다.
의존성은 추상화의 방향으로 향하게 딘다.

#### 추상화 정도 측정하기

지표 A는 컴포넌트 클래스의 개수 대비 인터페이스와 추상 클래스의 개수를 단순히 계산한 값이다.
지표 A는 0과 1사이의 값을 갖는다.
0이면 추상 클래스가 하나도 없다는 뜻이다.
1이면 추상 클래스만을 포함한다는 뜻이다.

#### 주계열 (The main sequence, 천문학 용어로, 관측된 모든 별 중의 90%가 표시되어 있는 좁은 띠를 말한다)

![image](https://user-images.githubusercontent.com/17442457/223473542-b8755daa-9c83-4140-9e4e-5252dd98381d.png)

안정성(I)과 추상화 정도(A) 사이의 관계
안정적이고 추상화된 컴포넌트는 (0, 1)에 위치
불안정하며 구체화된 컴포넌트는 우측 하단인 (1, 0)에 위치

![image](https://user-images.githubusercontent.com/17442457/223474460-bde8122f-c58f-443c-a802-ec59e018b230.png)

컴포넌트가 위치할 수 있는 합리적인 지점이 있고
컴포넌트가 절대 위치해서는 안되는 영역인 배제할 구역Zone of Exclusion을 찾는 방식으로 추론할 수 있다.

##### 고통의 구역

(0, 0) 주변 구역
이 컴포넌트는 안정적이며 구체적이다.
바람직한 상태가 아닌데 추상적이지 않으므로 확장할 수 없고, 안정적으로 변경하기도 상당히 어렵다.
(0, 0) 주변 영역은 배제해야할 구역이며, 고통의 구역Zone of Pain이라고 부른다.

예제1, 데이터베이스 스키마: 애플리케이션과 데이터베이스 사이에 위치한 인터페이스는 관리하기가 어렵고 스키마가 변경되면 대체로 고통을 수반한다.

예제2, 유틸리티 라이브러리: String 컴포넌트, 이 컴포넌트에 속한 클래스는 모두 구체 클래스다. 이 컴포넌트가 수정되면 혼란을 초래할 수 있으므로 String은 변동성이 없다.

고통의 구역에 위치한 컴포넌트가 변동성이 크면 클수록 수반되는 고통은 더욱 '고통'스럽다.

##### 쓸모없는 구역

(1, 1) 주변의 컴포넌트
최고로 추상적이지만 누구도 그 컴포넌트에 의존하지 않기 때문에 이 컴포넌트는 쓸모가 없다.
이 영역은 쓸모없는 구역Zone of Uselessness이라고 부른다.

누구도 구현하지 않은 채 남겨진 추상 클래스인 경우가 많다.

#### 배제 구역 벗어나기

각 배제 구역으로 부터 멀리 떨어진 점의 궤적은 (1, 0)과 (0, 1)을 잇는 선분이다.
이 선분을 주계열Main Sequence이라고 부른다.

컴포넌트가 위치할 수 있는 가장 바람직한 지점은 주계열의 두 종점이다.
뛰어난 아키텍트라면 대다수의 컴포넌트가 두 종점에 위치하도록 만들기 위해 매진한다.

#### 주계열과의 거리

이상적인 상태로부터 컴포넌트가 얼마나 멀리 떨어져 있는지 측정하는 지표를 만들어 볼 수 있다.

D: 거리. D=|A+I-1|
이 지표의 유효범위는 [0, 1]이다.
D가 0이면 컴포넌트 주계열 바로 위에 위치한다는 뜻이며
1이면 주계열로부터 가장 멀리 위치한다는 뜻이다.

설계를 통계적으로 분석하는 일이 가능해진다.
설계에 포함된 모든 컴포넌트에 대해 D 지표의 평균과 분산을 구한다.
주계열에 일치하도록 설계하면 평균과 분산은 0에 가까워진다.
분산을 통해 다른 컴포넌트에 비해 '극히 예외적인' 컴포넌트를 식별할 수 있다.

D지표를 통해 컴포넌트의 D 값을 시간에 따라 그려보고 의존성의 변화를 감지할 수 있다.
컴포넌트가 주계열에서 멀리 벗어난 원인을 시간을 들여 조사해볼 가치가 있다.

### 결론

의존성 관리 지표는 훌륭한 패턴이라고 생각하는 수준에 부합하는지를 측정해 볼 수 있다.
지표는 아무리 해도 불완전하고 임의로 결정한 표준으로 한 측정값이 지나지 않는다.
그래도 지표로 부터 무언가 유용한 것을 찾으면 좋다.