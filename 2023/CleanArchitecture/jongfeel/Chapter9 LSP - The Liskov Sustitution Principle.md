## 9장 LSP: 리스코프 치환 원칙

1988년 바바로 리스코프Barbara Liskov는 하위 타입subtype을 아래와 같이 정의했다.

> 여기에서 필요한 것은 다음과 같은 치환substitution 원칙이다. S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위타입이다.

리스코프 치환 원칙Liskov Substitution Principle, LSP이다.

### 상속을 사용하도록 가이드하기

License 클래스는 calcFee()라는 메서드를 가지며, Billing 애플리케이션에서 이 메서드를 호출한다.
License는 PersonalLicense와 BusinsessLicense라는 두 가지 '하위 타입'이 존재한다.

이 설계는 LSP를 준수하는데, Billing 애플리케이션의 행위가 License 하위 타입 중 무엇을 사용하는지에 전혀 의존하지 않기 때문이다.
하위 타입은 모두 License 타입을 치환할 수 있다.

### 정사각형/직사각형 문제

Rectangle을 상속받는 Square 클래스가 있다고 할 때 이는 LSP를 위반하는 문제로 볼 수 있다.
Rectangle의 높이와 너비는 서로 독립적으로 변경할 수 있지만 (setH(), setW())
Square의 높이와 너비는 반드시 함께 변경되기 때문에(setSide()) 문제를 일으킬 수 있다.

Rectangle이 실제로 Square인지 검사하는 매커니즘을 추가하면 해결할 수 있지만
결국 Squrre 타입에 의존하게 되므로 타입을 치환할 수 없게 된다.

### LSP와 아키텍처

LSP의 초창기에는 상속을 사용하도록 가이드 하는 방법 정도였지만
인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙으로 변모해 왔다.

아키텍처 관점에서 LSP를 이해하는 최선의 방법은 이 원칙을 어겼을 때 시스템 아키텍처에서 무슨 일이 일어나는지 관찰하는 것이다.

### LSP 위배 사례

택시 파견taxi dispatch 서비스를 통합하는 애플리케이션의 예제
설명 생략

### 결론

LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다.
지환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.