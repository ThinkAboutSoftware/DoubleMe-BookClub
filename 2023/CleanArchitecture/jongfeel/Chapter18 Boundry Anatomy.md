## 18장 경계 해부학

### 경계 횡단하기

‘런타임에 경계를 횡단한다’ 함은 그저 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일에 불과하다. 적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있다.

### 두려운 단일체

물리적으로 엄격하게 구분되지 않는 형태는 함수와 데이터가 단일 프로세서에서 같은 주소 공간을 공유하며 그저 나름의 규칙에 따라 분리되어 있을 뿐이다.

배포 관점에서 보면 이는 소위 단일체monolith 라고 불리는 단일 실행 파일에 지나지 않는다.

배포 관점에서 볼 때 단일체는 경계가 드러나지 않는다. 그렇다고 해서 단일체에는 경계가 실제로 존재하지 않거나, 경계 자체가 무의미하다는 뜻은 아니다.

가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출이다. 이 경우 런타임 의존성과 컴파일타임 의존성은 모두 같은 방향, 즉 저수준 컴포넌트에서 고수준 컴포넌트로 향한다.

단일체에서 컴포넌트 간 통신은 매우 빠르고 값싸다. 통신은 전형적인 함수 호출에 지나지 않기 때문이다. 결과적으로, 소스 수준에서 결합이 분리되면 경계를 가로지르는 통신은 상당히 빈번할 수 있다.
단일체를 배포하는 일은 일반적으로 컴파일과 정적 링크 작업을 수반하므 로, 대체로 이러한 시스템에서 컴포넌트는 소스 코드 형태로 전달된다.

### 배포형 컴포넌트

단일체와 마찬가지로 배포형 컴포넌트의 경계를 가로지르는 통신은 순전히 함수 호출에 지나지 않으므로 매우 값싸다. 동적 링크와 런타임 로딩으로 인해 최초의 함수 호출은 오래 걸릴 수 있지만, 대체로 이들 경계를 가로지르는 통신은 매우 빈번할 것이다.

### 스레드

스레드는 아키 텍처 경계도 아니며 배포 단위도 아니다. 이보다 스레드는 실행 계획과 순서를 체계화하는 방법에 가깝다.

### 로컬 프로세스

대개의 경우 로컬 프로세스는 소켓socket 이나 메일박스mailbox , 메시지 큐
message queue 와 같이 운영체제에서 제공하는 통신 기능을 이용하여 서로 통신 한다.

로컬 프로세스 경계를 지나는 통신에는 운영체제 호출, 데이터 마샬링 및언마샬링, 프로세스 간 문맥 교환 등이 있으며, 이들은 제법 비싼 작업에 속한 다. 따라서 통신이 너무 빈번하게 이뤄지지 않도록 신중하게 제한해야 한다.

### 서비스

물리적인 형태를 띠는 가장 강력한 경계는 바로 서비스다. 서비스들은 모든 통신이 네트워크를 통해 이뤄진다고 가정한다.

서비스 경계를 지나는 통신은 함수 호출에 비해 매우 느리다. 이 수준의 통신에서는 지연latency 에 따른 문제를 고수준에서 처리할 수 있어야 한다.

### 결론

단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용한다.

대체로 한 시스템 안에서도 통신이 빈번한 로컬 경계와 지연을 중요하게 고려해야 하는 경계가 혼합되어 있음을 의미한다.