## 34장 빠져 있는 장

문제는 항상 디테일(구현 세부사항)에 있는 법이며, 이점을 심사숙고하지 않는 다면 마지막 고비에 걸려 넘어지기 십상일 것이다.

### 계층 기반 패키지

기술적인 관점에서 해당 코드가 하는 일에 기반해 그 코드를 분할한다. 흔히 우리는 이 방식을 ‘계층 기반 패키지’라고 부른다.

코드는 계층이라는 얇은 수평 조각으로 나뉘며, 각 계층은 유사한 종류의 것들을 묶는 도구로 사용된다. ‘엄격한 계층형 아키텍처’의 경우 계층은 반드시 바로 아래 계층에만 의존해야 한다.

<img width="479" alt="image" src="https://user-images.githubusercontent.com/17442457/232495464-08e4fefb-c86d-485a-a8af-1993c7f4103d.png">

처음 시작하기에는 계층형 아키텍처가 적합하다.

이 아키텍처는 엄청난 복잡함을 겪지 않고도 무언가를 작동시켜 주는 아주 빠른 방법이다. 문제는, 마틴이 지적했듯이 소프트웨어가 커지고 복잡해지기 시작하면, 더 잘게 모듈 화해야 할지를 고민하게 될 것이다.

계층형 아키텍처는 업무 도메인에 대해 아무것도 말해주지 않는다는 문제도 있다.

### 기능 기반 패키지

이는 서로 연관된 기능, 도메인 개념, 또는 Aggregate Root에 기반하여 수직의 얇은 조각으로 코드를 나누는 방식이다.

<img width="479" alt="image" src="https://user-images.githubusercontent.com/17442457/232495600-a88c63cd-d642-425f-9d61-02acf19325d6.png">

인터페이스와 클래스는 이전과 같지만, 모두가 단 하나의 패키지에 속하게 된다. 이는 ‘계층 기반 패키 지’를 아주 간단히 리팩터링한 형태지만, 이제 코드의 상위 수준 구조가 업무 도메인에 대해 무언가를 알려주게 된다. 이 코드 베이스가 웹, 서비스, 리포지터리가 아니라 주문과 관련한 무언가를 한다는 걸 볼 수 있다.

### 포트와 어댑터

‘포트와 어댑터Ports and Adapters’ 혹은 ‘육각형 아키텍처Hexago-
nal Architecture’, ‘경계, 컨트롤러, 엔티티BCE’ 등의 방식으로 접근하는 이유는 업무/도메인에 초점을 둔 코드가 프레임워크나 데이터베이스 같은 기술적인 세부 구현과 독립적이며 분리된 아키텍처를 만들기 위해서다.

<img width="478" alt="image" src="https://user-images.githubusercontent.com/17442457/232495891-ecd3464e-967d-43ab-bea2-dd114274847d.png">

‘내부’ 영역은 도메인 개념을 모두 포함하는 반면, ‘외부’ 영역은 외부 세계(예를 들면 UI, 데이터베이스, 서드파티 통합)와의 상호작용을 포함한다. 여기서 주요 규칙은 바로 ‘외부’가 ‘내부’에 의존하며, 절대 그 반대로는 안 된다는 점이다.

<img width="480" alt="image" src="https://user-images.githubusercontent.com/17442457/232495974-9e452bd5-81ac-4b8f-89da-bdf58e1e53d2.png">

도메인 주도 설계에서는 ‘내부’에 존재하는 모든 것의 이름은 반드시 ‘유비쿼터스 도메인 언어 ubiquitous domain language’ 관점에서 기술하라고 조언한다. 바꿔 말하면, 도메인에 대해 논의할 때 우리는 ‘주문’에 대해 말하는 것이지, ‘주문 리포지터리’에 대해 말하는 것이 아니다.

### 컴포넌트 기반 패키지

엄격한 계층형 아키텍처에서는 의존성 화살표는 항상 아래를 향해야 하며, 각 계층은 반드시 바로 아래 계층에만 의존해야 한다. 여기에는 큰 문제가 있다. 속임수를 써서 몇몇 의존성을 의도치 않은 방식으로 추가하더라도, 보기에는 여전히 좋은 비순환 의존성 그래프가 생성된다는 사실이다.

<img width="478" alt="image" src="https://user-images.githubusercontent.com/17442457/232496080-6e7fffca-8947-481f-997b-b3bb04d5357a.png">

의존성 화살표는 여전히 아래를 향하지만, 이제 몇몇 유스케이스에서는
OrdersController가 OrdersService를 우회하고 있다. 이러한 조직화는 계층가 인접한 계층(들)을 건너뛰는 일이 허용되기 때문에 흔히 완화된 계층형 아키텍처라고 부른다. 경우에 따라 이는 의도된 결과이기도 한데, 예를 들어 CQRS 패턴을 지키려고 시도하는 경우다. 이외의 경우에서는 업무 로직 계층을 우회하는 일은 바람직하지 못하다.

여기에서 우리에게 필요한 것은 지침(아키텍처 원칙)으로, “웹 컨트롤러는 절대로 리포지터리에 직접 접근해서는 안 된다”와 같은 원칙이 필요하다. 물론 문제는 강제성이다.

이 같은 신뢰는 듣기에는 좋지만, 자금이 바닥나거나 납기가 다가오면 무슨 일이 벌어지는지를 우리는 이미 잘 알고 있다.

가능하면 컴파일러를 사용해서 아키텍처를 강제하는 방식을 선호한다.
‘컴포넌트 기반 패키지’를 도입해야 하는 이유는 바로 이 때문이다.

이 접근법은 서비스 중심적인 시각으로 소프트웨어 시스템을 바라 보며, 마이크로서비스 아키텍처가 가진 시각과도 동일하다. 포트와 어댑터 에서 웹을 그저 또 다른 전달 메커니즘으로 취급하는 것과 마찬가지로, 컴포 넌트 기반 패키지에서도 사용자 인터페이스를 큰 단위의 컴포넌트로부터 분리해서 유지한다.

<img width="478" alt="image" src="https://user-images.githubusercontent.com/17442457/232496185-4c16dea6-3c0c-4b13-a30d-5f1aa6a77bf2.png">

본질적으로 이 접근법에서는 ‘업무 로직’과 영속성 관련 코드를 하나로 묶는 데, 이 묶음을 나는 ‘컴포넌트’라고 부른다.

컴포넌트 기반 패키지 접근법의 주된 이점은 주문과 관련된 무언가를 코딩해야 할 때 오직 한 곳, 즉 OrdersComponent 만 둘러보면 된다는 점이다. 이컴포넌트 내부에서 관심사의 분리는 여전히 유효하며, 따라서 업무 로직은 데이터 영속성과 분리되어 있다. 이는 마이크로서비스나 서비스 지향 아키텍처를 적용했을 때 얻는 이점과도 유사하다. 큰 차이는 결합 분리 모드에 있다. 모노리틱 애플리케이션에서 컴포넌트를 잘 정의하면 마이크로서비스 아키텍처로 가기 위한 발판으로 삼을 수 있다.

### 구현 세부사항엔 항상 문제가 있다 (THE DEVIL IS IN THE IMPLEMENTATION DETAILS)

세부사항을 잘못 구현하면 아키텍처를 보는 시각도 빠르게 흐트러지기 시작한다.

자바에서 public 접근 지시자를 지나칠 절도로 방만하게 사용하는데, 코드 베이스에서 지향한 아키텍처 스타일과도 아무런 관련이 없다.

모든 타입에서 public 지시자를 사용한다는 건 사용하는 프로그래밍 언어가 제공하는 캡슐화 관련 이점을 활용하지 않겠다는 뜻이다. 이런 방식은 구현단계에서 직접 코드를 작성해서 객체를 생성하는 걸 걸 막을 수 없으므로 아키텍처 스타일을 위반하게 된다.

### 조직화 vs. 캡슐화

만약 모든 타입을 public으로 지정한다면 패키지는 단순히 조직화를 위한 매커니즘으로 전락하여 캡슐화를 위한 메커니즘이 될 수 없다. 패키지를 무시해 버리면 캡슐화나 은닉을 하는 데 아무런 도움도 되지 않으므로 최종적으로 어떤 아키텍처 스타일로 만들려고 하는지는 아무런 의미가 없어진다.

만약 다이어그램을 패키지 구조를 살려서 제한적인 접근 지시자를 사용할 수 있는 타입을 (흐리게) 표시하면, 다이어그램은 상당히 인상적으로 변한다.

<img width="482" alt="image" src="https://user-images.githubusercontent.com/17442457/232499003-60f80553-0370-4560-afe5-6309dfeccb19.png">

각 패키지 접근법으로 살펴보면

- 계층 기반 패키지 접근법에서 구현 클래스는 더 제한적으로 선언할 수 있다. (패키지 protected) 구현 클래스는 외부에서 알 필요가 없는 구현 세부사항이다
- 기능 기반 패키지 접근법에서는 OrdersController가 패키지로 들어올 수 있는 유일한 통로이므로 나머지는 모두 패키지 protected로 지정할 수 있다.
- 포트와 어댑터 접근법에서는 OrderService와 Orders 인터페이스는 외부로부터 들어오는 의존성을 가지므로 public을 지정해야 한다. 여기서도 구현 클래스는 패키지 protected로 지정할 수 있고 런타임에 의존성 주입을 할 수 있다.
- 컴포넌트 기반 패키지 접근법에서는 컨트롤러에서 OrdersComponent 인터페이스로 향하는 의존성을 가지며, 그 외의 모든 클래스는 패키지 protected로 지정할 수 있다. 컴파일러의 도움을 받아 아키텍처 접근법을 강제할 수 있다. .NET에서도 internal 키워드를 사용하면 동일한 결과를 얻을 수 있다.

이 내용은 모노리틱 애플리케이션에 대한 내용이지만 아키텍처 원칙을 강제할 때는 자기 규율이나 컴파일 후처리 도구를 이용하지 말고 반드시 컴파일러에 의지할 것을 권장한다.

### 다른 결합 분리 모드

자바의 OSGi 모듈 프레임워크나 자바 9에서 제공하는 새로운 모듈 시스템을 사용하면, public 타입과 외부에 공표할 타입을 분리할 수 있다.

다른 선택지로 소스 코드 수준에서 의존성 분리를 하는 방법도 있다. 정확하게 서로 다른 소스 코드 트리로 분리하는 방법이다. 구현 관점에서 이렇게 분리하려면 빌드 도구(gradle, msbuild)를 사용해서 모듈이나 프로젝트가 서로 분리되도록 구성해야 한다.

이상적인 방법이지만, 현실에서는 소스 코드를 이렇게 나누면 성능 복잡성, 유지보수 문제가 생긴다.

포트와 어댑터 접근법을 적용할 때는 소스 코드 트리 두 개만 만든다. 도메인 코드(내부)와 인프라 코드(외부)
이 다이어그램에서 인프라는 도메인에 대해 컴파일 시점의 의존성을 가진다.

<img width="479" alt="image" src="https://user-images.githubusercontent.com/17442457/232502649-83bf9076-7d0b-4e23-9cf3-56695a63fe0e.png">

소스 코드를 조직화할 때는 효과가 있지만 잠재적으로 절충해야 하는 부분이 있는데 '포트와 어댑터에 대한 페리페리크 안티 패턴(Périphérique anti-pattern of ports and adapters)'이라고 부른다. 프랑스 파리에 있는 블러바드 페리페리크 라는 원형 순환 도로가 있는데 이 도로를 타면 파리 시내에 진입하지 않고 파리 전체를 돌 수 있다. 애플리케이션에서도 특정 영역(웹 컨트롤로)에 있는 인프라 코드가 다른 영역(데이터베이스 리포지터리)에 있는 코드를 도메인을 통하지 않고 직접 호출할 수 있다는 뜻이다.

### 결론: 빠져 있는 조언

구현 전략에 얽힌 복잡함을 고려하지 않으면 설계가 순식간에 망가질 수도 있다.
설계를 어떻게 해야만 원하는 코드 구조로 매핑할 수 있을지, 그 코드를 어떻게 조직화할지, 런타임과 컴파일타임에 어떤 결합 분리 모드를 적용할지 고민하라.
가능하다면 선택사항을 열어두되, 실용주의적으로 행하라.
팀의 규모, 기술 수준, 해결책의 복잡성을 일정과 예산이라는 제약과 동시에 고려하라.
선택한 아키텍처 스타일을 강제하는 데 컴파일러의 도움을 받을 수 있을지 고민하고, 데이터 모델과 같은 다른 영역에 결합되지 않도록 주의하라.
악마는 구현 세부사항에 있다. (The devil is in the implementation details.) 