## 13장 컴포넌트 응집도

### REP: 재사용/릴리스 등가 원칙Reuse/Release Equivalence Principle

> 재사용 단위는 릴리스 단위와 같다

소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나 릴리스 번호가 부여되지 않는다면 해당 컴포넌트를 재사용하고 싶어도 할 수 없고, 하지도 않을 것이다.

소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 뜻한다.
컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 한다.

컴포넌트가 REP를 위배하면 컴포넌트 사용자가 알게 되고, 당신의 아키텍트로서의 능력을 높게 평하지 않을 것이다.

### CCP: 공통 폐쇄 원칙Common Closure Principle

> 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 사로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.

단일 책임 원칙SRP을 컴포넌트 관점에서 다시 쓴 것이다.

CCP는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권한다.
물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야 한다.
이를 통해 소프트웨어를 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화할 수 있다.

#### SRP와의 유사성

> 동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.

### CRP: 공통 재사용 원칙Common Reuse Principle

> 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.

같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다고 말한다.

간단한 사례로 컨테이너container 클래스와 해당 클래스의 이터레이터iterator 클래스를 들 수 있다.
이들 클래스는 서로 강하게 결합되어 있기 때문에 함께 재사용된다.

의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다.
그렇지 않다면 필요 이상으로 많은 컴포넌트를 재배포하느라 우리의 소중한 노력을 허비하게 된다.
따라서 CRP는 어떤 클래스를 한데 묶어도 되는지보다는, 어떤 클래스를 한데 묶어서는 안 되는지에 대해서 훨씬 더 많은 것을 이야기한다. 

#### ISP와의 관계

CRP는 인터페이스 분리 원칙ISP의 포괄적인 버전이다.

> 필요하지 않은 것에 의존하지 말라.

### 컴포넌트 응집도에 대한 균형 다이어그램

REP와 CCP는 포함inclusive 원칙이다. 이 원칙들은 컴포넌트를 더욱 크게 만든다.
CRP는 배제exclusive 원칙이며, 컴포넌트를 더욱 작게 만든다.
뛰어난 아키텍트라면 이 원칙들이 균형을 이루는 방법을 찾아야 한다.

![image](https://user-images.githubusercontent.com/17442457/223176396-b60884a8-e408-478c-b1bf-aed61388312a.png)

REP와 CRP에만 중점을 두면, 사소한 변경이 생겼을 때 너무 많은 컴포넌트에 영향을 미친다.
CCP와 REP에만 과도하게 집중하면 불필요한 릴리스가 너무 빈번해진다.

뛰어난 아키텍트라면 이 균형 삼각형에서 개발팀이 관심을 기울이는 부분을 충족시키는 위치를 찾아야 하며,
시간이 흐르면서 주의를 기울이는 부분이 변한다는 사실도 이해하고 있어야 한다. 

프로젝트 초기에는 CCP가 REP보다 중요한데, 개발 가능성이 재사용성보다 중요하기 때문이다.
프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 변하는데 프로젝트가 실제로 수행하는 일 자체보다는 프로젝트가 발전되고 사용되는 방법과 더 관련이 깊다.

### 결론

컴포넌트를 만들 때 결정할 건 재사용성과 개발 가능성이라는 상충하는 힘을 반드시 고려해야 한다.
균형점은 시간이 지나면서 유동적이다.
프로젝트의 초점이 개발가능성에서 재사용성으로 바뀌고, 그에 따라 컴포넌트를 구성하는 방식도 조금씩 흐트러지고 또 진화한다.