## 4장 구조적 프로그래밍

### 증명

데이크스트라는 수학자가 유클리드 계층구조를 사용하는 방식을 프로그래머도 사용할 수 있다고 믿었다.
프로그래머는 입증된 구조를 이용하고, 이들 구조를 코드와 결합시키며, 코드가 올바르다는 사실을 스스로 증명하게 되는 방식이었다.

goto 문장은 모듈을 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견했다.
goto 문의 좋은 사용 방식은 if/then/else와 do/while과 같은 분기와 반복이라는 단순한 제어 구조에 해당한다는 사실을 발견했다.

제어 구조는 순차 실행sequential excution과 결합했을 때 특별하다는 사실을 발견했고
뵘과 야코피니가 모든 프로그램을 순차sequence, 분기selection, 반복iteration이라는 세 가지 구조만으로 표현할 수 있다는 사실을 증명했다.
구조적 프로그래밍은 이렇게 탄생했다.

데이트스트라는 열거법을 이용한 순차 구문sequential statement이 올바름을 입증할 수 있다는 사실을 보여주었다.
분기selection는 열거법을 재적용하는 방식으로 처리, 두 경로가 수학적으로 적절한 결과를 만들어낸다면, 증명은 신뢰할 수 있게 된다.
반복iteration은 반복이 올바름을 증명하기 위해 귀납벅indeuction을 사용했다. 반복의 시작과 종료 조건도 열거법을 통해 증명했다.

### 해로운 성명서

1968년 데이크스트라는 CACMCommunications of the ACM 편집자에게 "goto문의 해로움Go To Statement Considered Harmful" 이라는 편지를 보냈고, 세 가지 제어 구조에 대한 의견을 피력했다.

부정적, 긍정적 견해에 대한 의견이 많았고 10년간 지속되었다.
그리고 논쟁은 수그러들고 goto문은 사라지게 되었다.

현재 우리 모두는 구조적 프로그래머이다.
제어흐름을 제약 없이 직접 전환할 수 있는 선택권 자체를 언어에서 제공하지 않기 때문이다.

### 기능적 분해

구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고,
이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻했다.
분해한 기능들은 구조적 프로그래밍의 제한된 제어 구조를 이용ㅇ하여 표현할 수 있다.

1970 ~ 1980년대에 구조적 분석structured analysis이나 구조적 설계structured design과 같은 기법이 인기를 끌었다.
이 기법을 쓰면 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고,
이걸 입증할 수 있는 아주 작은 기능들로 세분화할 수 있다.

### 엄밀한 증명은 없었다

대개의 프로그래머들은 세세한 기능 하나하나를 엄밀히 증명하는 고된 작업에서 이득을 얻으리라고는 보지 않았다.
하지만 유클리드 방식같이 엄밀한 수학적 증명만이 있는 것은 아니었기 때문에,
또 다른 전략인 과학적 방법scientific method으로 이걸 해결했다.

### 과학이 구출하다

과학적 방법은 반증은 가능하지만 증명은 불가능하다.
과학은 서술된 내용이 사실임을 증명하는 방식이 아니라 서술이 틀렸음을 증명하는 방식으로 동작한다.

### 테스트

프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다.
소프트웨어는 과학과 같다. 최선을 다하더라도 올바르지 않음을 증명하는 데 실패함으로써 올바름을 보여주기 때문이다.

구조적 프로그래밍은 증명 가능한 세부 집합으로 재귀적으로 분해한다.
테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도한다.
이 테스트가 실패한다면 목표에 부합할 만큼은 충분히 참이라고 여기게 된다.

### 결론

구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 능력 때문이다.
아키텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여긴다.
소프트웨어 아키텍트는 모듈, 컴포넌ㅌ, 서비스가 쉽게 반증 가능하도록 - 테스트하기 쉽도록 만들기 위해 분주히 노력해야 한다.