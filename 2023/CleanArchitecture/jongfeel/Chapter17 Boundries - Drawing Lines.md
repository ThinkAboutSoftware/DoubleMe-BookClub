## 17장 경계: 선 긋기

소프트웨어 아키텍처는 선을 긋는 기술이며, 이러한 선을 경계boundary라고 부른다.
경계는 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하도록 막는다.

시스템을 만들고 유지하는데 드는 인적 자원의 효율을 떨어뜨리는 요인이 있는데 그걸 결합coupling이라고 한다.
이른 결정에 따른 결합이 문제인데 시스템의 업무 요구사항, 유스케이스와 아무런 관련이 없는 결정이다.
좋은 시스템 아키텍처는 이런 결정이 부수적이며 의존적이지 않다.
좋은 시스템 아키텍처는 이런 결정을 가능한 한 최후의 순간에 내릴 수 있게 해주며, 결정에 따른 영향이 크지 않게 만든다.

### 두 가지 슬픈 이야기

P회사에 대한 이야기
데스크톱 GUI 애플리케이션에서 웹 기반 버전의 솔루션 개발 진행

단일 장비에서 실행하고 있음에도 직렬화, 마샬링/언마샬링, 메시지 구성 및 파싱, 소켓 통신들, 다른 추가 작업들 까지 실행하는 일을 지속했다.
이런 일은 아키텍트가 너무 이르게 결정을 내려서 개발 비용을 엄청나게 가중시킨 사례다.

W사의 사례
작은 기업에 모든 특성이 구비된 엔터프라이즈급의 서비스 지향 아키텍처로 구성
새로운 기능을 추가하려면 모든 서비스 사이의 결합으로 인해 엄청난 양의 WSDLWeb Services Description Language을 변경해야 하며, 변경에 영향을 받는 모든 것을 다시 배포해야 한다.
W사의 실수는 SOA를 약속하는 일련의 도구를 너무 일찍 채택해 적용했다는 사실이다.

### FitNesse

초기에 내린 결정 중 하나는 FitNesse의 요구에 특화된, 우리만의 웹 서버를 직접 작성하자는 것이었다.

초기에 내린 또 다른 결정은 데이터베이스에 대해 고민하지 말자는 것이 었다.

FitNesse 개발 초기에 우리는 업무 규칙과 데이터베이스 사이에 경계선boundary line을 그었다. 이 경계선을 통해 업무 규칙은 데이터 접근 메서드 외에는 데이터베이스에 관해서 어떤 것도 알지 못하게 되었다.

경계선을 긋는 행위는 결정을 늦추고 연기하는 데 도움이 되었고, 궁극적으로는 시간을 엄청나게 절약해주었으며, 골치를 썩지 않게 해주었다. 이것이 바로 좋은 아키텍처라면 반드시 해야 하는 일이다.

### 어떻게 선을 그을까? 그리고 언제 그을까?

데이터베이스는 업무 규칙이 간접적으로 사용할 수 있는 도구다. 업무 규칙은 스키마, 쿼리 언어, 또는 데이터베이스와 관련된 나머지 세부사항에 대해 어떤 것도 알아서는 안된다. 업무 규칙이 알아야 할 것은 데이터를 가져오고 저장할 때 사용할 수있는 함수 집합이 있다는 사실이 전부다. 이러한 함수 집합을 통해서 우리는 데이터베이스를 인터페이스 뒤로 숨길 수 있다.

BusinessRules 에게 있어 Database 는 문제가 되지 않지만, Database 는 BusinessRules 없이는 존재할 수 없다는 사실을 방향을 통해 알 수 있다.

두 컴포넌트 사이에 이러한 경계선을 그리고 화살표의 방향이 Business Rules 를 향하도록 만들었으므로, BusinessRules 에서는 어떤 종류의 데이터 베이스도 사용할 수 있음을 알 수 있다. Database 컴포넌트는 다양한 구현체로 교체될 수 있으며, BusinessRules 는 조금도 개의치 않는다.

### 입력과 출력은?

GUI 와 BusinessRules 컴포넌트가 경계선에 의해 분할된다는 사실을 볼 수 있다

GUI 는 다른 종류의 인터페이 스로 얼마든지 교체할 수 있으며 BusinessRules 는 전혀 개의치 않는다는 사실을 알 수 있다.

### 플러그인 아키텍처

소프트웨어 개발 기술의 역사는 플러그인을 손쉽게 생성하여, 확장 가능하며 유지보수가 쉬운 시스템 아키텍처를 확립할 수 있게 만드는 방법에 대한 이야기다. 선택적이거나 또는 수많은 다양한 형태로 구현될 수 있는 나머지 컴포넌트로부터 핵심적인 업무 규칙은 분리되어 있고, 또한 독립적이다.

### 플러그인에 대한 논의

시스템을 플러그인 아키텍처로 배치함으로써 변경이 전파될 수 없는 방화 벽을 생성할 수 있다.

경계는 변경의 축 axis of change 이 있는 지점에 그어진다. 경계의 한쪽에 위치한 컴포넌트는 경계 반대편의 컴포넌트와는 다른 속도로, 그리고 다른 이유로 변경된다.

업무 규칙은 의존성 주입 프레임워크와는 다른 시점에 그리고 다른 이유로 변경되므로, 둘 사이에도 반드시 경계가 필요하다.
이 역시도 순전히 단일 책임 원칙에 해당한다. 단일 책임 원칙은 어디에 경계를 그어야 할지를 알려준다.

### 결론

소프트웨어 아키텍처에서 경계선을 그리려면 먼저 시스템을 컴포넌트 단위로 분할해야 한다. 일부 컴포넌트는 핵심 업무 규칙에 해당한다. 나머지 컴포넌트는 플러그인으로, 핵심 업무와는 직접적인 관련이 없지만 필수 기능을 포함한다. 그런 다음 컴포넌트 사이의 화살표가 특정 방향, 즉 핵심 업무를 향하도록 이들 컴포넌트의 소스를 배치한다.
이는 의존성 역전 원칙과 안정된 추상화 원칙을 응용한 것임을 눈치챌 수있어야 한다. 의존성 화살표는 저수준 세부사항에서 고수준의 추상화를 향하도록 배치된다.