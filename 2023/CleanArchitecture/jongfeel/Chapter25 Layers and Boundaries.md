## 25장 계층과 경계

간단한 컴퓨터 게임에서는 세 가지 컴포넌트(UI, 업무 규칙, 데이터베이스)로만 구성된다고 생각해 볼 수 있다.
이게 전부일지는 더 생각해 봐야 할 문제다.

### 움퍼스 사냥 게임

텍스트를 기반으로 하는 단순한 명령어를 사용하는 게임이다.
텍스트 기반 UI는 유지하고 게임 규칙과 UI를 분리해서 다양한 언어로 발매할 수 있게 만든다고 가정해 보면?

소스 코드 의존성을 관리해서 UI 컴포넌트가 어떤 언어를 사용해도 게임 규칙을 재사용할 수 있게 만들 수 있다.
게임을 저장하는 것도 세부사항을 알지 못하게 만든다면 플래시 메모리, 클라우드, RAM에 저장하는지 모르게 할 수 있다.

### 클린 아키텍처?

이 정도의 맥락이면 클린 아키텍처 접근법을 사용해서 유스 케이스, 경계, 엔티티, 데이터 구조를 만드는 일도 쉬운 일일 수 있다.
하지만 더 나아간다면 텍스트를 주고 받는 매커니즘을 다양하게 만들 수도 있고
일반적인 셸shell 창을 사용하고 싶을 때도 있고
텍스트 메시지나 채팅 애플리케이션을 사용할 수도 있다.

여기에는 다양한 가능성이 존재한다.

아키텍처의 구성은 데이터의 흐름을 두 개의 흐름으로 효과적으로 분리할 수 있다.
왼쪽의 흐름은 사용자와의 통신
오른쪽의 흐름은 데이터 영속성에 관여한다.
두 흐름은 GameRules에서 서로 만나며, GameRules는 두 흐름이 모두 거치게 되는 데이터에 대한 최적인 처리기가 된다.

![image](https://user-images.githubusercontent.com/17442457/229589913-f9720bcc-fc99-4d88-a721-599600f02741.png)

### 흐름 횡단하기

데이터의 흐름은 항상 두 가지가 아닐 수도 있다. 게임이 네트워크 상에서 멀티 플레이가 된다고 해보면 Network 컴포넌트를 추가해야 한다. 그러면 흐름이 3개로 분리되며, 역시 GameRules가 제어한다.

![image](https://user-images.githubusercontent.com/17442457/229590107-91e918ee-84fd-4ddc-9190-9fd6282fe205.png)

### 흐름 분리하기

GameRules보다 더 높은 수준에 정책 집합이 존재한다.
플에이어 생명력, 특정 사건을 해결하는 비용과 얻게 될 소득을 알고 있는 정책이다. FoundFood(식량 발견)나 FellInFit(구덩이에 빠짐)과 같은 이벤트가 그렇다. 이런 이벤트는 고수준정책에서 플레이어의 상태를 관리한다. 그리고 게임이 끝났을 때 플레이어의 승리 여부도 이 정책에서 결정한다. 

### 결론

콘 셸Korn shell에서 200줄 정도면 구현할 수 있는 간단한 프로그램으로 이런 아키텍처를 추론해 내는 이유는?
아키텍처의 경계는 어디에나 존재한다는 걸 보여주기 위한 예제이다.
아키텍트로서 아키텍처 경계가 언제 필요한지를 신중하게 파악해내야 한다.
이러한 경계는 비용이 많이 든다는 사실도 인지하고 있어야 한다.

오버 엔지니어링은 나쁠때가 훨씬 많다. 추상화가 필요하리라고 미리 예측해서는 안 된다.
어떤 아키텍처 경계도 존재하지 않는 상황에서 경계가 필요하다는 사실을 발견하면,
그 경계를 추가하기 위해 많은 비용이 들고 위험을 감수해야 한다.

소프트웨어 아키텍트는 미래를 내다봐야 한다. 현명하게 추측해야 한다. 경계를 결정해야만 한다.
이는 일회성 결정은 아니다. 경계가 무엇인지 쉽게 결정할 수 없다.
대신 시스템이 발전함에 따라 주의를 기울여야 한다.

첫 조짐이 보이는 시점이 될 때 경계를 구현하는 비용과 무시할 때 감수할 비용을 가늠해 본다.
목표를 달성하려면 빈틈없이 지켜봐야 한다.